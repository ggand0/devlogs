# Replay Mode Stability Fixes

**Date:** 2025-08-23

## Overview

Fixed critical reliability issues in ViewSkater's replay mode that were causing intermittent failures during automated performance testing. The replay mode would sometimes get "stuck" after the first iteration, requiring manual mouse movement to continue, which defeated the purpose of autonomous testing.

## Issues Identified

### Issue 1: Event Loop Stagnation (Two-Layer Problem)
**Problem**: The event loop would stop processing updates when replay mode reached navigation boundaries and no user input was present. This caused the app to appear "frozen" until mouse movement triggered new events.

**Root Cause - Layer 1 (winit Event Loop)**: 
winit's event loop only processes updates when it receives external events (mouse movement, keyboard input, window events, etc.). During autonomous replay mode:
- No user input means no events
- Event loop transitions from `ControlFlow::Poll` to `ControlFlow::Wait`
- Application stops updating entirely

**Root Cause - Layer 2 (Iced Task System)**: 
Even when winit is polling, Iced's `update()` method only gets called when there are pending tasks or messages. During replay mode at boundaries:
- Navigation flags (`skate_left`/`skate_right`) would be set to `false`
- No more tasks would be generated by navigation functions
- Iced's update cycle stops running
- Replay controller's timing logic stops executing

**The Chain Reaction**: winit stops polling → Iced stops updating → replay controller stops timing → app appears frozen

### Issue 2: Navigation Boundary Infinite Loop
**Problem**: When left navigation reached index 0, `move_left_all()` would enter an infinite loop instead of properly returning `Task::none()`.

**Root Cause**: Race condition in boundary detection logic where:
1. App successfully navigated to index 0
2. `move_left_all()` was called but boundary checks weren't consistently catching panes at index 0
3. Function would attempt to load/render "previous" images that don't exist
4. This created a cycle: load attempt → failure → retry → repeat

## Solutions Implemented

### Fix 1: Two-Layer Keep-Alive Mechanism
Addressed both layers of the event loop stagnation problem:

**Layer 1 Fix (winit Event Loop - main.rs)**:
Force continuous polling and updates even without external events:

```rust
// Force continuous polling during replay mode
let replay_active = state.program().replay_controller.as_ref().map_or(false, |rc| rc.is_active());

// Process updates even without user events
if !state.is_queue_empty() || replay_active {
    let (_, task) = state.update(/* ... */);
}

// Always request redraws and maintain polling during replay
if *redraw || replay_active {
    window.request_redraw();
    if replay_active {
        event_loop.set_control_flow(ControlFlow::Poll); // Keep polling!
    }
}
```

**Layer 2 Fix (Iced Task System - app.rs)**:
Generate continuous tasks to maintain Iced's update cycle:

```rust
// New message type for keep-alive
Message::ReplayKeepAlive,

// Continuous task generation in app.rs
if replay_controller.is_active() {
    self.replay_keep_alive_task = Some(Task::perform(
        async { 
            tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
        }, 
        |_| Message::ReplayKeepAlive
    ));
}
```

**The Two-Layer Solution**:
- **Layer 1**: Keep winit's event loop actively polling and processing updates
- **Layer 2**: Generate continuous tasks so Iced's update cycle never stops
- **Result**: Autonomous replay mode that doesn't depend on external events

### Fix 2: Multi-Layer Boundary Protection
Enhanced `move_left_all()` with multiple safety checks:

```rust
// Initial boundary check with logging
if panes_to_load.len() == 0 {
    debug!("move_left_all() - All panes at beginning (index 0), returning Task::none()");
    return Task::none();
}

// Additional safety check after pane collection
for pane in panes_to_load.iter() {
    if pane.img_cache.current_index == 0 {
        debug!("move_left_all() - Found pane at index 0 during processing, returning Task::none()");
        return Task::none();
    }
}

// Final check before rendering
for pane in panes_to_load.iter() {
    if pane.img_cache.current_index == 0 {
        debug!("move_left_all() - Pane reached index 0 before rendering, returning Task::none()");
        return Task::none();
    }
}
```

### Additional Improvements

**Enhanced State Synchronization**:
- Added boundary detection in `app.rs` to sync navigation flags with replay controller state
- Implemented timeout fallback mechanism (duration + 1s) to force progress if stuck
- Clear navigation flags when reaching actual boundaries

**Multi-Iteration Support**:
- Added `RestartIteration` action to avoid full directory reload between iterations
- Enhanced replay state machine with `WaitingForReady` state
- Improved iteration counting and completion logic

**Better Debug Visibility**:
- Added comprehensive logging at all boundary detection points
- Enhanced replay controller state debugging
- Clear progress indicators during navigation phases

## Results

**Before Fix**:
- Replay mode would get stuck after first iteration ~50% of the time
- Required manual mouse movement to continue
- Unreliable for automated performance testing
- Would sometimes enter infinite loops consuming CPU

**After Fix**:
- Replay mode runs completely autonomously through all iterations
- No manual intervention required
- Reliable automated performance testing
- Clean completion with proper resource cleanup

## Testing

Tested with various configurations:
- Single/multiple directories
- Left/right/both navigation directions
- Multiple iterations (1-10)
- Different durations (1s-30s)
- Various navigation intervals (50ms-500ms)

All test scenarios now complete successfully without manual intervention.

## Technical Details

**Files Modified**:
- `src/main.rs`: Event loop modifications for continuous polling
- `src/app.rs`: Keep-alive mechanism, state sync, boundary detection
- `src/navigation_keyboard.rs`: Multi-layer boundary protection
- `src/replay.rs`: Enhanced state machine, multi-iteration support

**Key Architecture Changes**:
1. **Continuous Task Generation**: Ensures event loop never goes idle during replay
2. **Proactive Boundary Detection**: Multiple checkpoints prevent infinite loops
3. **State Synchronization**: App navigation flags stay in sync with replay controller
4. **Graceful Degradation**: Timeout mechanisms prevent permanent stuck states

The fixes maintain backward compatibility and don't affect normal (non-replay) usage of the application.
